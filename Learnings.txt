Project Workflow:

Problem Statement

Design ER diagram

Create Models with Data Validation

Migrate the DB and update...

If DB ready,

Creating controllers to process or read that models.

Creating views for respective action methods to render html with model data.



Learnt:

1. Data Annotations

1.1 Where Validation occurs??
[Required], would work on the server. The client-side validation is a bonus added only when you include jQuery validation plugin.
So don't need to worry if someone turns off JavaScript on the browser. You will still get the server-side validation by the MVC framework when the data posts back to the server.
That would also mean client-side validation cannot trusted. You can see it would be easy for others to by-pass the client-side validation and submit data to the server (i.e., using 3rd party tool like Postman).

1.2: Nullable for setting null and required is for set the value to validate success...
[Required]
public DateTime? OrderDate { get; set; }

Nullable: makes sure, that we do not see "0" for integer and some "dafault" date when the entry form is loaded.
And [Required] make sure, that value is always entered from the user.
Then model validate will be performed efficiently without any defaults....

https://stackoverflow.com/questions/43688968/what-does-it-mean-for-a-property-to-be-required-and-nullable#:~:text=so%2C%20Nullable%3A%20makes%20sure%2C,saw%20when%20form%20got%20loaded).

2. Bind[attributes] User user vs User user
The Model validation considering the data coming from client to server then only we will interact with DB.
Bind[attributes] User user : Validates only specified attributes in that model.
User user : Validates the required attributes which inputs are taken from the View.

3. [NeverBind] annotation in a model
The model neglects that attribute at the time of model validation

4. ModelState
It have entries of attributes validation which inputs are tken from the client in the view.

5. View("action","data") vs RedirectToAction("action","controller")

6. How every View is Rendered with Layout View: 

The _ViewStart.cshtml file is executed before every view that is rendered. If you define the layout inside _ViewStart.cshtml, 
it will apply to all views within the application.
@{
    Layout = "~/Views/Shared/_Layout.cshtml";
}

When a request is made to an action method that returns a view, the view engine renders the specified view within the layout. 
- The view (Index.cshtml, About.cshtml, etc.) is selected by the controller action.
- The content of the view is rendered and then placed inside the layout file at the location of @RenderBody().

7. Model states for Business logic then why we write business logic at controllers?? 
- We can create an extra layer as service layer in between Controller and data acccess layer
https://stackoverflow.com/questions/18563229/mvc-where-to-put-business-logic




-- error prone checks [Errors]

1. If we don't pass data to the Views, 
Case 1: when We are rendering model data (using @Model) in the view then it throws
NullReferenceException
InvalidOperationException
Case 2: when We are not rendering model data (using @Model) in the view then it render smoothly without any hesitation.

Make sure if you wanna render model data in the view first check for NullReferenceException then use it.

2.Disabled fields aren't submitted. The email not goes in object with model binding at action
            <div class="form-group">
                <label asp-for="UserEmail" class="control-label"></label>
                <input asp-for="UserEmail" class="form-control" value=@ViewData["userEmail"] disabled />
            </div>

Sol: When an input field is disabled (<input disabled ... />), its value is not sent with the form submission. 
Better to sent that field as hidden field without user input.

3. Logout button click not calling post action?? 405 Error - Method Not Allowed
Sol: write button as submit btn in a form with post method

4. How can I access signed user data?? Make an endpoint so that signed user only access his tasks?? 
Sol: No, the entire user object is not stored.
Only the claims you explicitly added are stored in the authentication cookie.

5.The action runs success but not returning to Index view
 [HttpPost]
        public async Task<IActionResult> Clear()
        {
            if(_context.Tasks.Count() > 0)
            {
                var tasks = _context.Tasks.ToList();
                _context.Tasks.RemoveRange(tasks);
                _context.SaveChanges();
                await Response.WriteAsync("Cleared"); 
            }
            else
            {
                await Response.WriteAsync("No Tasks");
            }  
            return View(nameof(Index),_context.Tasks.ToList());
        }
Sol: Calling Response.WriteAsync() writes raw content directly to the response body, which makes it hard for ASP.NET MVC to 
process the view rendering after that. Once you start writing to the response, the action method can't return a view, 
as part of the response is already sent to the client.